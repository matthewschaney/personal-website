<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>From Bits to Prompts: The Vanishing Craft of Programming - Matthew Schaney</title>
  <meta name="description" content="Abstraction built modern software - but what do we lose when the layers hide the machine?" />
  <link rel="canonical" href="https://schaney.net/writing/from-bits-to-prompts/" />
  <meta property="og:title" content="From Bits to Prompts: The Vanishing Craft of Programming" />
  <meta property="og:description" content="Abstraction built modern software - but what do we lose when the layers hide the machine?" />
  <meta property="og:type" content="article" />
  <meta property="og:image" content="/assets/og-image.png" />
  <meta property="article:published_time" content="2025-08-31" />
  <meta property="article:author" content="Matthew Schaney" />
  <link rel="icon" href="/assets/favicon.svg" type="image/svg+xml" />
  <link rel="stylesheet" href="/styles.css" />
  <style>
    .prose { max-width: var(--measure); }
    .post-meta { color: var(--muted); margin-bottom: 1rem; }
  </style>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>
  <header class="site-header" role="banner">
    <nav class="nav" aria-label="Primary">
      <a class="logo" href="/"><span aria-hidden="true">‚åÇ</span><span class="sr-only">Home</span></a>
      <button id="themeToggle" class="theme-toggle" aria-label="Toggle theme">üåì</button>
      <ul class="nav-links">
        <li><a href="/#projects">Projects</a></li>
        <li><a href="/#experience">Experience</a></li>
        <li><a href="/#education">Education</a></li>
        <li><a href="/writing/" aria-current="true">Writing</a></li>
        <li><a href="/#contact">Contact</a></li>
      </ul>
    </nav>
  </header>

  <main id="main" class="article">
    <div class="container prose">
      <p class="muted" style="margin:0 0 .75rem"><a href="/writing/">‚Üê Back</a></p>

      <h1>From Bits to Prompts: The Vanishing Craft of Programming</h1>
      <p class="post-meta">By Matthew Schaney ¬∑ August 31, 2025</p>

      <p>In the 1950s, a programmer's work looked very different from today.
      Writing software meant carefully punching holes into cards, toggling switches
      on a machine, or feeding raw binary instructions into hardware. Every operation
      was tied to the physical reality of the computer itself. Compare that to today,
      when many developers can deploy a global-scale web application without ever
      touching a server, sometimes without even writing much ‚Äútraditional‚Äù code.</p>

      <p>The history of programming is, in many ways, the history of abstraction.
      Each generation building new layers that make the layers beneath less visible.</p>

      <h2>The Climb Up the Tower of Abstraction</h2>

      <p>The earliest programmers worked in machine code, streams of 1s and 0s that
      directly controlled a processor. Then came assembly language, a symbolic
      shorthand that replaced raw opcodes with human-readable mnemonics. The next
      great leap was high-level languages like Fortran, C, and later Java. These let
      programmers describe what they wanted to happen, leaving the compiler to handle
      how it happened on the machine. By the time object-oriented and functional
      paradigms took hold, developers were no longer thinking about registers and
      memory addresses - they were modeling problems in terms of real-world systems.</p>

      <p>Each step didn't erase what came before: it simply layered over it, creating a
      tower of abstraction.</p>

      <h2>Modern Abstractions: Invisible Machinery</h2>

      <p>Today, that tower has reached heights that would have stunned early programmers.
      Instead of writing networking code from scratch, most developers reach for a
      framework or library, pulling in prebuilt solutions with a single import. Rather
      than designing a database engine themselves, they rely on ORMs and schema tools
      that make persistence feel almost invisible. Even infrastructure has been pulled
      away from the keyboard - cloud services and APIs allow anyone to spin up storage,
      scale workloads, or harness thousands of machines with just a few lines of
      configuration. And increasingly, entire applications can be built without
      traditional code at all. Low-code platforms, drag-and-drop editors, and AI
      assistants allow intent to be described in natural language, leaving the system
      to generate the details. In many cases, someone with no formal training can now
      assemble software that once required a team of specialists.</p>

      <h2>The Benefits of Abstraction</h2>

      <p>This layering isn't a bad thing. It's the reason modern software development is
      possible at all. Without abstraction, every developer would still be wrestling
      with assembly. Abstraction accelerates development by orders of magnitude,
      letting teams deliver in days what once took months. It also lowers the barrier
      to entry, making technology accessible to people who never would have considered
      themselves programmers in the past. And perhaps most importantly, it allows
      developers to focus on solving problems instead of constantly reinventing the
      same technical wheels.</p>

      <p>In this sense, abstraction has democratized programming, turning it from an
      elite technical art into a widely shared capability.</p>

      <h2>The Costs of Forgetting What Lies Beneath</h2>

      <p>But every abstraction comes with a cost. When a dependency or platform fails,
      many developers are left helpless because they don't understand what's happening
      at the lower layers. Abstractions also trade away control - cloud providers and
      closed ecosystems make it easy to get started, but they can quietly lock teams
      into choices that are expensive to undo. And perhaps most concerning is the slow
      erosion of understanding. Developers who never peer under the hood may find
      themselves struggling with debugging, optimization, or true innovation. It's the
      paradox of modern software: we are more powerful than ever, yet often less aware
      of the machinery that grants us that power.</p>

      <h2>The Road Ahead</h2>

      <p>Where does this trend lead? Some imagine a future where programming itself
      disappears, replaced by natural language conversations with AI systems that
      generate and maintain software.</p>

      <p>Others argue that there will always be a need for people who understand the
      deeper layers - just as we still need metallurgists and engineers, even if most
      of us never touch raw steel.</p>

      <p>Programming may never vanish, but it is transforming. It is no longer just
      about ‚Äúwriting instructions for machines.‚Äù Increasingly, it is about expressing
      intent and letting layers of abstraction translate that intent into reality.</p>

      <h2>Conclusion</h2>

      <p>Abstraction is the essence of progress in programming - it has allowed us to
      build skyscrapers of software instead of shacks of code. But as those
      skyscrapers grow taller, we risk losing touch with the foundations beneath
      them.</p>

      <p>The future of programming will not be decided by whether abstraction
      continues - it always will - but by whether we remember that, beneath the layers,
      it all still comes down to bits.</p>

    </div>
  </main>

  <footer class="site-footer">
    <div class="container">
      <small>¬© <span id="year"></span> Matthew Schaney. Built with plain HTML/CSS/JS. 
        <a href="https://github.com/matthewschaney/personal-website">Source</a>.
      </small>
    </div>
  </footer>
  <script src="/script.js" defer></script>
</body>
</html>
